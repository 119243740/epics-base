# CONFIG.win32-x86.win32-x86
#
# $Id$
# This file is maintained by the build community.
#
# Definitions for win32-x86 target archs when host arch is win32-x86
# Sites may override these definitions in CONFIG_SITE.win32-x86.win32-x86
#-------------------------------------------------------

# Win32 valid build types and include directory suffixes

VALID_BUILDS = Host Ioc

#-------------------------------------------------------

# 	Use std path variables from ms
HOME = $(HOMEDRIVE)$(HOMEPATH)

#
# You currently get Visual C++ even if you ask for GNU.
#
# !! borlund support needed here !!
#
ANSI = ACC
CPLUSPLUS = CCC

#
# "\ " forces gnu make to keep this as one token
#
MSVISC = c:\\Program\ Files\\DevStudio\\Vc
WINLINK = link

RCCMD = rc -l 0x409 -I. -I.. $(INSTALL_INCLUDES) -fo $@ $<

ARCMD = lib /nologo /verbose /out:$@ 
###	$(addsuffix .lib,$($*_SYS_DLL_LIBS) $(SYS_DLL_LIBS))

BAFCMD = bscmake /nologo /o $@

#
# Configure OS vendor C compiler
ACC = cl 

#
# __STDC__=0 is a real great idea of Jeff that gives us both:
# 1) define STDC for build code (pretend ANSI conformance)
# 2) set it to 0 to use MS C "extensions" (open for _open etc.)
# because MS uses:   if __STDC__ ... disable many nice things
#
# Use of /Za would dissable DLL import/export keywords which
# include/excludes using architecture neutral macros
ACC_CONFORM_CFLAGS_ANSI = /nologo /D__STDC__=0 
ACC_CONFORM_CFLAGS_STRICT = /nologo /D__STDC__=0 
ACC_CONFORM_CFLAGS_TRAD = /nologo

#
# /W<N> use warning level N
# (maximum (lint type) warnings at level 4)
ACC_WARN_YES = /W3
ACC_WARN_NO =  /W1

#
# /Ox maximum optimizations
# /MD use MSVCRT (run-time as DLL, multi-thread support)
ACC_OPT_YES = /Ox

#
# /Zi include debugging info in object files
# /Fr create source browser file
ACC_OPT_NO = /Zi /Fr

#
# the following options are required when
# vis c++ compiles the code (and includes
# the header files)
#
# /MT static multithreaded C RTL
# /MTd static multithreaded C RTL (debug version)
# /MD multithreaded C RTL in DLL
# /MDd multithreaded C RTL in DLL (debug version)
VISC_DLL_NO = -DEPICS_DLL_NO
VISC_DLL_YES = 
VISC_DLL = $(VISC_DLL_$(SHARED_LIBRARIES))
VISC_STATIC_CFLAGS_DEBUG_NO = d
VISC_STATIC_CFLAGS_DEBUG_YES =
VISC_STATIC_CFLAGS_DEBUG = $(VISC_STATIC_CFLAGS_DEBUG_$(HOST_OPT))
ACC_STATIC_CFLAGS_YES= /MT$(VISC_STATIC_CFLAGS_DEBUG) $(VISC_DLL)
ACC_STATIC_CFLAGS_NO= /MD$(VISC_STATIC_CFLAGS_DEBUG) $(VISC_DLL)

#
# no special libs for static link
#
ACC_STATIC_LDLIBS_YES= ws2_32.lib advapi32.lib user32.lib kernel32.lib winmm.lib
ACC_STATIC_LDLIBS_NO=

# OS vendor c preprocessor
ACC_CPP = cl  /E

# Configure OS vendor C++ compiler
#
# __STDC__=0 is a real great idea of Jeff that gives us both:
# 1) define STDC for code (pretend ANSI conformance)
# 2) set it to 0 to use MS C "extensions" (open for _open etc.)
# because MS uses:   if __STDC__ ... disable many nice things
#
# Use of /Za would dissable DLL import/export keywords which
# include/excludes using architecture neutral macros
CCC = cl 
CCC_CONFORM_CFLAGS_NORMAL = /nologo /D__STDC__=0 /GX
CCC_CONFORM_CFLAGS_STRICT = /nologo /D__STDC__=0 /GX
CCC_TEMPL_INST_FLAG =

#
# /W<N> use warning level N
# (maximum lint level warnings at level 4)
CCC_WARN_YES = /W3
CCC_WARN_NO =  /W1

#
# /Ox maximum optimizations
CCC_OPT_YES = /Ox

#
# /Zi include debugging info in object files
# /Fr create source browser file
CCC_OPT_NO = /Zi /Fr

#
# the following options are required when
# vis c++ compiles the code (and includes
# the header files)
#
# /MT static multithreaded C RTL
# /MTd static multithreaded C RTL (debug version)
# /MD multithreaded C RTL in DLL
# /MDd multithreaded C RTL in DLL (debug version)
CCC_STATIC_CFLAGS_YES= /MT$(VISC_STATIC_CFLAGS_DEBUG) $(VISC_DLL)
CCC_STATIC_CFLAGS_NO= /MD$(VISC_STATIC_CFLAGS_DEBUG) $(VISC_DLL)

#
# no special libs for static link
#
CCC_STATIC_LDLIBS_YES=ws2_32.lib advapi32.lib user32.lib kernel32.lib winmm.lib
CCC_STATIC_LDLIBS_NO= 
 
LINK_OPT_FLAGS_YES = /WARN:3 /incremental:no /opt:ref\
/release $(PROD_VERSION:%=/version:%)
LINK_OPT_FLAGS_NO = /WARN:3 /debug 
OPT_LDFLAGS = $(LINK_OPT_FLAGS_$(HOST_OPT))

ARCH_DEP_CFLAGS=

#	to identify the general architecture class:
#	should be BSD, SYSV, WIN32, ...
#	is: WIN32, sun4, hpux, linux, ...
#
OS_CLASS=WIN32

#	ifdef WIN32   looks better that  ifeq ($(OS_CLASS),WIN32)  ??
WIN32=1

EXE=.exe
OBJ=.obj
RES=.res
BAF=.bsc
BOF=.sbr

#       Problem: MS Visual C++ does not recognize  *.cc as C++ source,
#       we have to compile xx.cc  using the flag -Tp xx.cc,
#       i.e.  -Tp  has to be immediately before the source file name
SOURCE_CXXFLAG = /Tp

#	Operating system flags 
OP_SYS_CFLAGS =

#
# WIN32 specific include files
#
#OP_SYS_INCLUDES = -I$(INSTALL_INCLUDE)\\os\\WIN32

#
# These are now added to the individual makefiles that use them in order to
# speed up the build
#
#OP_SYS_LDLIBS = user32.lib kernel32.lib advapi32.lib winmm.lib
OP_SYS_LDLIBS = 

#	Files and flags needed to link DLLs (used in RULES_BUILD)
#
#	Strange but seems to work without: WIN32_DLLFLAGS should contain
#	an entry point:
#		'-entry:_DllMainCRTStartup$(DLLENTRY)'
DLLENTRY = @12

WIN32_DLLFLAGS = /subsystem:windows /dll $(OPT_LDFLAGS)

#
# specify dll .def file only if it exists
#
DLL_DEF_FLAG = $(addprefix /def:,$(wildcard ../$(BUILD_LIBS).def))

#	HOST_OPT_FLAGS is part of CFLAGS/CXXFLAGS,
#	which in turn are used in COMPILE.c[c]
#
#	If we compile a .c, .cc into an $(OBJ),
#	we test if this object is part of the 
#	library objects LIBOBJS_HOST.
#	If so, we define _WINDLL so that
#	e.g. include/shareLib.h works correctly.
#
HOST_OPT_FLAGS += $(subst $@, /_WINDLL, $(findstring $@,$(LIBOBJS_HOST)))

#
#	A WIN32 dll has three parts:
#	x.dll: the real dll (SHRLIBNAME)
#	x.lib: what you link to progs that use the dll (LIBNAME)
#	x.exp: what you need to build the dll (in no variable)
#
LINK.shrlib = $(WINLINK) /nologo $(WIN32_DLLFLAGS) /implib:$*.lib /out:$*.dll $(DLL_DEF_FLAG)

#	adjust names of libraries to build
#
#	But: if there are no objects LIBOBJS to include
#	in this library (may be for e.g. base/src/libCompat
#	on some archs), don't define (and build) any library!
SHRLIB_SUFFIX=.dll
SHRLIBNAME = $(BUILD_LIBRARY:%=%$(SHRLIB_SUFFIX))


#
# Under WIN32 we have the unique situation where the DLL link creates the
# DLL link library xxx.lib and we need to be very careful to avoid replacing
# the xxx.lib created by the dll link with an xxx.lib created by $(AR).
# Therefore, the object library is named xxxObj.lib
#
# SHARED_LIBRARIES is YES if we are building a DLL and NO if we aren't
#
DLL_LINK_LIBNAME_YES = $(BUILD_LIBRARY:%=%.lib)
DLL_LINK_LIBNAME = $(DLL_LINK_LIBNAME_$(SHARED_LIBRARIES))
LIB_PREFIX=
LIB_SUFFIX=Obj.lib
LIBNAME = $(BUILD_LIBRARY:%=%$(LIB_SUFFIX))

#	dll install location
INSTALL_SHRLIB = $(INSTALL_BIN)

#--------------------------------------------------
# Object lib name suffix
OBJECT_LIB_EXT_YES = Obj.lib # object library extension for static build
OBJECT_LIB_EXT_NO = .lib # object library extension for dynamic build
OBJECT_LIB_EXT = $(OBJECT_LIB_EXT_$(STATIC_BUILD))

#--------------------------------------------------
# Products dependancy definitions
PROD_DEPLIBS = $(foreach lib,$(PROD_LIBS) $(USR_LIBS),$(firstword \
		$($(lib)_DIR)/$(lib)$(OBJECT_LIB_EXT)))
DEPLIB_LDLIBS = $($*_DEPLIBS) $(PROD_DEPLIBS) \
		$($*_SYS_LIBS:%=%.lib) $(SYS_PROD_LIBS:%=%.lib)

#--------------------------------------------------
#Libraries dependancy definitions

#	EPICS libs that we need to link the DLL with
#	(it isnt necessary to rebuild the dll if these change)
DLL_DEPLIBS = $(foreach lib,$($*_DLL_LIBS) $(DLL_LIBS),$($(lib)_DIR)/$(lib).lib)

SHRLIB_LDLIBS = $(DLL_DEPLIBS) $($*_SYS_DLL_LIBS:%=%.lib) \
	$(SYS_DLL_LIBS:%=%.lib) $(OP_SYS_LDLIBS)

#--------------------------------------------------
# Linker definition
LINK.cpp = $(WINLINK) -nologo $(LDFLAGS) -out:$@

#--------------------------------------------------

#     Use std path variables from ms
HOME = $(HOMEDRIVE)$(HOMEPATH)

# override of CONFIG_SITE
SHARED_LIBRARIES = YES

